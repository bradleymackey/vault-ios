import Foundation
import FoundationExtensions
import VaultCore

/// A `VaultItem` retrieved from storage.
///
/// Includes the unique ID used to identify this item.
public struct VaultItem: Equatable, Hashable, Identifiable, Sendable {
    /// An item of data that can be stored in the Vault.
    public enum Payload: Equatable, Hashable, Sendable {
        case otpCode(OTPAuthCode)
        case secureNote(SecureNote)
    }

    /// Information about the stored item.
    public var metadata: Metadata
    /// The stored vault item.
    public var item: Payload

    public init(metadata: Metadata, item: Payload) {
        self.metadata = metadata
        self.item = item
    }

    public var id: UUID {
        metadata.id
    }

    /// Maps this object to a `VaultItem.Write` for writing.
    ///
    /// This discards any non-deterministic data and identifiable information.
    public func makeWritable() -> VaultItem.Write {
        .init(
            relativeOrder: metadata.relativeOrder,
            userDescription: metadata.userDescription,
            color: metadata.color,
            item: item,
            tags: metadata.tags,
            visibility: metadata.visibility,
            searchableLevel: metadata.searchableLevel,
            searchPassphase: metadata.searchPassphrase,
            lockState: metadata.lockState
        )
    }

    /// Checks if all deterministic content in a given vault item is equal to an `other` item.
    ///
    /// This ignores data that is not user-determined.
    /// For example, the created and updated date.
    func isContentEqual(to other: VaultItem) -> Bool {
        // The 'writable' content is all deterministic
        makeWritable() == other.makeWritable() &&
            id == other.id
    }
}

extension VaultItem.Payload {
    public var otpCode: OTPAuthCode? {
        switch self {
        case let .otpCode(otpCode):
            otpCode
        default:
            nil
        }
    }

    public var secureNote: SecureNote? {
        switch self {
        case let .secureNote(note):
            note
        default:
            nil
        }
    }
}

extension VaultItem {
    /// Common metadata for all stored vault items.
    public struct Metadata: Equatable, Hashable, Identifiable, Sendable {
        /// A unique ID to identify this specific `item`.
        ///
        /// This should be generated by the storage layer.
        public let id: UUID
        public let created: Date
        public var updated: Date
        public var relativeOrder: UInt64?
        /// User-provided description about the item.
        public var userDescription: String
        public var visibility: VaultItemVisibility
        public var searchableLevel: VaultItemSearchableLevel
        public var tags: Set<Identifier<VaultItemTag>>
        public var searchPassphrase: String?
        public var lockState: VaultItemLockState
        /// The color tint for this item.
        public var color: VaultItemColor?

        public init(
            id: UUID,
            created: Date,
            updated: Date,
            relativeOrder: UInt64?,
            userDescription: String,
            tags: Set<Identifier<VaultItemTag>>,
            visibility: VaultItemVisibility,
            searchableLevel: VaultItemSearchableLevel,
            searchPassphrase: String?,
            lockState: VaultItemLockState,
            color: VaultItemColor?
        ) {
            self.id = id
            self.created = created
            self.updated = updated
            self.relativeOrder = relativeOrder
            self.userDescription = userDescription
            self.tags = tags
            self.visibility = visibility
            self.searchableLevel = searchableLevel
            self.searchPassphrase = searchPassphrase
            self.lockState = lockState
            self.color = color
        }
    }
}

extension VaultItem {
    /// Model used for creating or updating a new `VaultItem`, where the `id` is predetermined/generated randomly.
    public struct Write: Equatable, Sendable {
        public var relativeOrder: UInt64?
        public var userDescription: String
        public var color: VaultItemColor?
        public var item: Payload
        public var tags: Set<Identifier<VaultItemTag>>
        public var visibility: VaultItemVisibility
        public var searchableLevel: VaultItemSearchableLevel
        public var searchPassphase: String?
        public var lockState: VaultItemLockState

        public init(
            relativeOrder: UInt64?,
            userDescription: String,
            color: VaultItemColor?,
            item: Payload,
            tags: Set<Identifier<VaultItemTag>>,
            visibility: VaultItemVisibility,
            searchableLevel: VaultItemSearchableLevel,
            searchPassphase: String?,
            lockState: VaultItemLockState
        ) {
            self.relativeOrder = relativeOrder
            self.userDescription = userDescription
            self.color = color
            self.item = item
            self.tags = tags
            self.visibility = visibility
            self.searchableLevel = searchableLevel
            self.searchPassphase = searchPassphase
            self.lockState = lockState
        }
    }
}
